import re
from dataclasses import dataclass
from typing import List, Optional

@dataclass
class FileModification:
    """Represents a single file to be created or modified in the plan."""
    relative_path: str
    content: str
    language: Optional[str] = None

# Regex to find filenames (e.g., in Markdown headers or specific lines)
# and subsequent code blocks. This needs to be robust to variations in LLM output.
# Adjusted to look for `path/to/file.ext` followed by a code block.
# We assume the LLM uses a reasonable format like:
# **File:** `path/to/file.py`
# ```python
# content
# ```
# or
# Create `path/to/file.yaml`:
# ```yaml
# content
# ```
# This regex is an attempt and might need refinement based on actual LLM output.

PLAN_FILE_REGEX = re.compile(
    # Look for potential file paths - be flexible (might need refinement)
    # Capture group 1: the file path (non-greedy)
    # Allows backticks, bold, or just the path
    r"(?:`|\*\*)([\w\./\-_]+(?:\.[a-zA-Z0-9]+)?)(?:`|\*\*)[\s:]*\n+"
    # Match the start of the code block, capture optional language hint (group 2)
    r"```(\w*)?\n"
    # Match the code content (group 3), non-greedily
    r"(.*?)?"
    # Match the end of the code block
    r"\n```",
    re.IGNORECASE | re.MULTILINE | re.DOTALL
)

# Simpler regex if the LLM consistently uses our previous `# filename:` format
# FILE_BLOCK_REGEX = re.compile(
#     r"^# filename: (.+)\n```(\w*)?\n(.*?)?\n```",
#     re.MULTILINE | re.DOTALL
# )

def parse_plan(plan_text: str) -> List[FileModification]:
    """
    Parses the plan text generated by the LLM to extract file modifications.

    Args:
        plan_text: The raw markdown string containing the plan.

    Returns:
        A list of FileModification objects.
    """
    modifications = []
    for match in PLAN_FILE_REGEX.finditer(plan_text):
        try:
            relative_path = match.group(1).strip()
            language = match.group(2).strip() if match.group(2) else None
            content = match.group(3).strip() if match.group(3) else ""

            # Basic path validation
            if not relative_path or ".." in relative_path or relative_path.startswith("/"):
                 print(f"Warning: Skipping potentially invalid path found in plan: {relative_path}")
                 continue

            modifications.append(
                FileModification(
                    relative_path=relative_path,
                    content=content,
                    language=language
                )
            )
        except IndexError:
            # Handle cases where the regex matches unexpectedly
            print(f"Warning: Could not parse a potential file block near: {match.group(0)[:100]}...")
            continue

    # Fallback or alternative regex if the primary one fails?
    # Add more sophisticated parsing if needed.

    if not modifications:
        print("Warning: Could not parse any file modification blocks from the generated plan.")

    return modifications

# Example Usage
if __name__ == '__main__':
    test_plan = """
Here's the plan:

Create the main application file:
**File:** `src/app.py`
```python
import os

def main():
    print("Hello World")

if __name__ == "__main__":
    main()
```

We also need a requirements file.
Create `requirements.txt`:
```text
flask>=2.0
```

And a configuration file `config/settings.yaml`
```yaml
# Settings
database:
  host: localhost
```

This should set up the basic structure.
    """

    print("--- Parsing Test Plan ---")
    parsed_mods = parse_plan(test_plan)
    if parsed_mods:
        for mod in parsed_mods:
            print(f"- Path: {mod.relative_path}, Lang: {mod.language}, Content Len: {len(mod.content)}")
    else:
        print("No modifications parsed.")
    print("-------------------------")
