# gcode-agent Architecture

This document outlines the internal architecture of the `gcode-agent-cli` tool.

## Overview

The `gcode-agent` is a Python CLI tool designed to automate the generation of SaaS applications based on multi-step specifications, using Gemini models. It supports both direct CLI interaction and exposure via the Model Context Protocol (MCP).

The core workflow revolves around reading specification templates, combining them with the outputs of previously completed steps to build context, prompting an LLM (Gemini) to generate a plan for the current step, saving that plan as output, parsing the plan, and optionally applying file creation actions.

## Components

1.  **CLI Entry Point (`gcode_agent.py` & `gcode_agent/cli.py`)**
    *   Uses `argparse` to define commands (`init`, `generate`, `config`, `serve-mcp`) and their arguments (e.g., `--model`, `--api-key`, `--apply`, `step`).
    *   Handles global setup like checking for the `GEMINI_API_KEY`.
    *   Initializes the `GeminiClient` when needed by a command.
    *   Dispatches execution to the appropriate command handler function based on parsed arguments.

2.  **Command Handlers (`gcode_agent/commands/`)**
    *   `init_command.py` (`handle_init`): Creates the `.gcode-agent` directory structure (`spec`, `outputs`), copies specification templates, and creates the initial `config.json`.
    *   `generate_command.py` (`handle_generate`): Orchestrates the core generation logic for a single step:
        *   Identifies the current step and required template (`spec/`).
        *   Loads context from previous step outputs (`outputs/`).
        *   Constructs a detailed prompt including context and the current step template.
        *   Calls the `GeminiClient` to get a plan.
        *   Saves the generated plan to the `outputs/` directory.
        *   Calls the `plan_parser` to extract file actions.
        *   If `--apply` is used, attempts to create *new* files by invoking the `edit_file` tool (currently simulated via `call_edit_file_tool` placeholder).
        *   Reports files needing manual review (modifications or new files without `--apply`).
    *   `config_command.py` (`handle_config`): Reads/writes the `.gcode-agent/config.json` file to list, get, or set configuration values (e.g., `model`, `current_step`).

3.  **Core Logic (`gcode_agent/core/`)**
    *   `gemini_client.py` (`GeminiClient`): Provides a class-based interface to the `google-generativeai` SDK. Handles API key configuration, model initialization, making `generate_content` calls, and basic response handling.
    *   `plan_parser.py` (`parse_plan`, `FileModification`): Uses regular expressions to parse the Markdown plan generated by the LLM, extracting intended file paths and their content into `FileModification` objects.

4.  **MCP Server (`gcode_agent/mcp_server.py`)**
    *   Uses the `mcp` Python SDK (`FastMCP`) to create an ASGI application.
    *   Wraps the core agent functionalities (init, generate, config, spec access) as MCP tools and resources:
        *   `@mcp_app.resource("spec://...")`: Exposes specification templates from `.gcode-agent/spec/`.
        *   `@mcp_app.tool()`: Defines tools like `initialize_project`, `generate_step`, `get_config_value`, `set_config_value` which call the underlying command handlers.
    *   Includes a helper (`get_gemini_client`) to manage client initialization within the server context.
    *   Uses `uvicorn` to run the ASGI application when the `serve-mcp` command is invoked.

5.  **Project State & Configuration (`.gcode-agent/`)**
    *   `.gcode-agent/spec/`: Contains the copied specification *templates* provided during `init`.
    *   `.gcode-agent/outputs/`: Stores the actual output (the generated plan) for each successfully executed `generate stepN` command (e.g., `step1_output.md`, `step2_output.md`). This forms the context for subsequent steps.
    *   `.gcode-agent/config.json`: Stores project-specific configuration like the default model selected during `init` or set via the `config` command.

## Data Flow (Generate Command)

```mermaid
graph TD
    A[CLI: ./gcode_agent.py generate stepN --apply] --> B(cli.py: Parse Args);
    B --> C(cli.py: Initialize GeminiClient);
    C --> D(cli.py: Call handle_generate);
    D --> E(handle_generate: Read spec/stepN template);
    D --> F(handle_generate: Read outputs/step1..N-1 outputs);
    E --> G(handle_generate: Construct Prompt);
    F --> G;
    G --> H(handle_generate: Call GeminiClient.generate_content);
    H --> I(handle_generate: Receive Plan Text);
    I --> J(handle_generate: Save Plan to outputs/stepN_output.md);
    I --> K(handle_generate: Call plan_parser.parse_plan);
    K --> L(handle_generate: Iterate Modifications);
    L -- New File & --apply --> M(handle_generate: Call edit_file tool);
    L -- Existing File or no --apply --> N(handle_generate: Log Manual Action Needed);
    M --> O(handle_generate: Report Results);
    N --> O;
```

This architecture allows for step-by-step, context-aware generation driven by specification templates, with optional automated application of non-destructive file creations. 